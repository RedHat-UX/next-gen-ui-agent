# Next Gen UI Web Components Renderer

A framework-agnostic component system for server-side UI generation, designed to work alongside your existing React investment.

## Why This Exists

If you're managing an enterprise React application, you know the challenges: build tool configuration, dependency conflicts, framework version migrations, testing infrastructure, and the ongoing maintenance burden of keeping everything synchronized. This renderer offers a complementary approach that reduces that burden for AI-generated UI while preserving your existing React architecture.

### The Core Insight

When an LLM generates UI, it doesn't need React's component model, hooks, or virtual DOM. It needs to return **declarative markup** that the browser can render. Web components provide this with zero framework overhead, while still working seamlessly inside your React application.

## What This Does

The web components renderer generates server-side HTML using:

1. **Python/Jinja2 templates** - Server returns simple HTML strings
2. **Web components** - Browser-native custom elements (`<ngui-card>`, `<ngui-table>`)
3. **Lazy loading** - Components load on-demand via dynamic `import()`
4. **Custom Elements Manifest** - Machine-readable API documentation for LLM consumption

### Architecture Flow

```
LLM → Python Agent → Jinja2 Template → HTML String → Client → Lazy Load Component → Render
```

**Example:**

```python
# Server: Python renderer generates HTML
template.render({
    "title": "Movie Info",
    "fields": [{"name": "Director", "data": ["John Lasseter"]}]
})
```

```html
<!-- Server returns this HTML string -->
<ngui-card title="Movie Info">
  <dl slot="content">
    <dt>Director</dt>
    <dd>John Lasseter</dd>
  </dl>
</ngui-card>
```

```typescript
// Client: React app receives HTML, lazy loads component
await loadWebComponents(htmlString);  // Dynamically imports ngui-card.js
return <div dangerouslySetInnerHTML={{ __html: htmlString }} />;
```

## Why This Helps React Teams

### 1. **Reduces Your Bundle Complexity**

Your React bundle doesn't carry component definitions for AI-generated UI. They load separately, on-demand, from standard ES modules. No webpack config changes, no bundle size impact.

### 2. **Framework Flexibility Without Migration Risk**

Web components work in React, Vue, Angular, Svelte, or vanilla JS. If you need to migrate part of your stack (or integrate with other teams using different frameworks), these components just work. No rewrites required.

### 3. **Simpler Server-Side Rendering**

AI-generated UI becomes a Jinja2 template that returns an HTML string. No Node.js SSR, no hydration mismatch bugs, no React server components complexity. The server just renders strings.

### 4. **Separation of Concerns**

Your React application's components stay focused on application logic and user interactions. AI-generated display components live separately with their own lifecycle:

- **Your React App**: Complex state management, routing, data fetching, user interactions
- **NGUI Components**: Display-only UI generated by LLM, loaded on-demand

### 5. **Encapsulation That Actually Works**

Shadow DOM provides true style encapsulation. PatternFly v6 styles in `<ngui-card>` won't conflict with your application's CSS, even if you're still using PatternFly v5 in React.

### 6. **LLM Integration Without Training**

The Custom Elements Manifest (`custom-elements.json`) is machine-readable documentation. LLMs can discover component APIs, slots, and properties without being trained on your codebase. This makes AI-generated UI more reliable over time.

## How to Use This

### For Python Backend Engineers

Add a new component by creating a Jinja2 template:

```python
# libs/next_gen_ui_web_components_renderer/templates/ngui-table.jinja
<ngui-table>
  <table slot="content">
    {% for row in rows %}
    <tr>
      {% for cell in row %}
      <td>{{ cell }}</td>
      {% endfor %}
    </tr>
    {% endfor %}
  </table>
</ngui-table>
```

Register the renderer strategy:

```python
from next_gen_ui_web_components_renderer import WebComponentsTableRenderStrategy

class WebComponentsTableRenderStrategy(WebComponentsStrategyBase):
    pass
```

### For Frontend Engineers

Create a new web component:

```typescript
// libs/next_gen_ui_web/elements/ngui-table.ts
import { LitElement, html, css } from 'lit';
import { customElement, property } from 'lit/decorators.js';

@customElement('ngui-table')
export class NguiTable extends LitElement {
  static styles = css`
    :host {
      display: block;
    }
  `;

  render() {
    return html`
      <pf-table>
        <slot name="content"></slot>
      </pf-table>
    `;
  }
}
```

Build and copy to client:

```bash
cd libs/next_gen_ui_web
npm run build  # Compiles TS, generates manifest, copies to client
```

The client's `loadWebComponents()` utility automatically discovers and imports `ngui-table.js` when it appears in server-generated HTML.

## Key Design Decisions

### Why Lit?

Lit is 5KB and provides the minimal abstraction needed for web components. It's not a framework—it's a thin layer over the Web Components standard. No virtual DOM, no complex lifecycle, no build tool requirements.

### Why Not Just Use React?

You should keep using React for your application. This renderer handles a specific use case: **server-side generation of display-only UI by LLMs**. For that use case:

- HTML strings are simpler than JSX
- No hydration means no SSR complexity
- Framework independence future-proofs AI-generated UI
- Web components encapsulate PatternFly updates

### Why Server-Side Templates?

Python/Jinja2 is simpler than running a Node.js process for React SSR. The LLM agent is already in Python (LangChain/LangGraph), so generating HTML strings directly is the shortest path.

## Migration Path

This is **additive**, not a migration. Your existing React application continues working unchanged:

1. **Phase 1** (Current): AI-generated UI uses web components renderer
2. **Your React App**: No changes needed; web components render inside React via `dangerouslySetInnerHTML`
3. **Future**: Optionally adopt web components for specific use cases where encapsulation helps

No all-or-nothing decisions required.

## FAQ

**Q: Doesn't this fragment our component system?**

A: You already have fragmentation: server-rendered HTML, client-side React, possibly SSR for some routes. This adds one more boundary, but a well-defined one: "display-only UI generated by LLMs." The alternative is maintaining React component definitions that LLMs generate, which adds complexity to your build process and bundle.

**Q: What about TypeScript safety?**

A: The web components are written in TypeScript with full type definitions. The HTML strings from the server are typed as `{ response: string, type: "html" }`. You get type safety where it matters (component implementation) and pragmatic string handling where it doesn't (LLM output).

**Q: How do we test these?**

A: Web components are testable like any other DOM element. Use Web Test Runner, or import them into your existing Jest setup with a DOM environment. The Python templates are testable with standard Jinja2 testing patterns.

**Q: What if we need interactivity?**

A: Add it to the web component definition. Lit components support event handlers, state management, and all standard browser APIs. The component handles its own interactivity; the server just provides initial data via slots or attributes.

**Q: Can we use our existing PatternFly React components?**

A: Yes. These web components wrap PatternFly Elements (the web component versions of PatternFly), which are maintained separately from `@patternfly/react-core`. They're designed to work alongside React PatternFly components without conflicts.

## Further Reading

- [Custom Elements Manifest](https://github.com/webcomponents/custom-elements-manifest) - LLM-readable component documentation
- [Lit Documentation](https://lit.dev) - Web component development
- [PatternFly Elements](https://patternflyelements.org) - Design system web components
- [Web Components Work Everywhere](https://custom-elements-everywhere.com/) - Framework compatibility tests

## Support

For questions about the architecture or implementation, see `tests/ngui-e2e/README.md` for the full end-to-end example setup.
